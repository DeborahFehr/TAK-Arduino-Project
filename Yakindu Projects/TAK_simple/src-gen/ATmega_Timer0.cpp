/* Generated by YAKINDU Statechart Tools for Arduino v0.9.0 */

#include "ATmega_Timer0.h"

const unsigned int CYCLE_PERIOD = 100;
const unsigned char MAX_PERIOD = 16;
const unsigned char OVERFLOW_COMPARE_VALUE = 249;

bool runCycleFlag = false;
unsigned int overflows = 0;
unsigned int overflowCounter = 0;
unsigned char moduloRest = 0;

ISR(TIMER0_COMPA_vect) {
	overflowCounter++;
	
	if (overflowCounter == overflows && moduloRest != 0) {
		noInterrupts();
		OCR0A = (moduloRest * 0.001f * (16000000 / 1024)) - 1;
		interrupts();
	} else if (overflowCounter >= overflows) {
		noInterrupts();
		OCR0A = OVERFLOW_COMPARE_VALUE;
		interrupts();
	
		runCycleFlag = true;
		overflowCounter = 0;
	}
}

ATmega_Timer0::ATmega_Timer0(StatemachineInterface* statemachine, HardwareConnector* hardware) {
	this->statemachine = statemachine;
	this->hardware = hardware;
	
	for (unsigned char i = 0; i < MAX_PARALLEL_TIME_EVENTS; i++) {
		events[i].eventId = NULL;
	}
}

void ATmega_Timer0::start() {
	statemachine->init();
	statemachine->enter();
	hardware->init();
	init();
}

void ATmega_Timer0::init() {
	// initialize Timer0
	noInterrupts();
	TCCR0A = 0;     // set entire TCCR0A register to 0
	TCCR0B = 0;     // same for TCCR0B
	
	overflows = CYCLE_PERIOD / MAX_PERIOD;
	moduloRest = CYCLE_PERIOD % MAX_PERIOD;
	
	OCR0A = OVERFLOW_COMPARE_VALUE;
	
	// turn on CTC mode
	TCCR0A |= (1 << WGM01);
	
	// Set CS02 and CS00 bits for 1024 prescaler
	TCCR0B |= (1 << CS02);
	TCCR0B |= (1 << CS00);
	
	// enable timer compare interrupt
	TIMSK0 |= (1 << OCIE0A);
	
	// enable global interrupts
	interrupts();
}

void ATmega_Timer0::setTimer(TimedStatemachineInterface* timedStatemachine, sc_eventid eventId, sc_integer duration, sc_boolean isPeriodic) {
	for (unsigned char i = 0; i < MAX_PARALLEL_TIME_EVENTS; i++) {
		if (events[i].eventId == NULL) {
			events[i].timedStatemachine = timedStatemachine;
			events[i].eventId = eventId;
			events[i].overflows = duration / CYCLE_PERIOD;
			events[i].periodic = isPeriodic;
			events[i].overflowCounter = 0;
			events[i].eventRaised = false;
			break;
		}
	}
}

void ATmega_Timer0::unsetTimer(TimedStatemachineInterface* timedStatemachine, sc_eventid eventId) {
	for (unsigned char i = 0; i < MAX_PARALLEL_TIME_EVENTS; i++) {
		if (events[i].eventId == eventId) {
			events[i].eventId = NULL;
			break;
		}
	}
}

void ATmega_Timer0::runCycle() {
	if (runCycleFlag) {
		raiseTimeEvents();
		hardware->raiseEvents();
		statemachine->runCycle();
		hardware->syncState();
		runCycleFlag = false;
	}
	sleep();
}

void ATmega_Timer0::raiseTimeEvents() {
	for (unsigned char i = 0; i < MAX_PARALLEL_TIME_EVENTS; i++) {
		if (events[i].eventId == NULL) {
			continue;
		}
	
		events[i].overflowCounter++;
	
		if ((events[i].overflowCounter >= events[i].overflows) && !events[i].eventRaised) {
			events[i].timedStatemachine->raiseTimeEvent(events[i].eventId);
			events[i].overflowCounter = 0;
	
			if (!events[i].periodic) {
				events[i].eventRaised = true;
			}
		}
	}
}

void ATmega_Timer0::sleep() {
	hardware->prepareSleepMode();
	
	set_sleep_mode(SLEEP_MODE_IDLE);
	noInterrupts();
	sleep_enable();
	interrupts();
	sleep_cpu();
	sleep_disable();
}

void ATmega_Timer0::cancel() {
	TCCR0B = 0; // turn off the timer
}
